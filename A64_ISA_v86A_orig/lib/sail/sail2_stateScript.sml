(*Generated by Lem from ../../src/gen_lib/sail2_state.lem.*)
open HolKernel Parse boolLib bossLib;
open lem_pervasives_extra_sailTheory sail2_valuesTheory sail2_state_monadTheory;
open monadsyntax BasicProvers

val _ = numLib.prefer_num();



val _ = new_theory "sail2_state"

val _ = declare_monad ("sail2_state_monad", {
  bind = ``sail2_state_monad$bindS``,
  unit = ``sail2_state_monad$returnS``,
  ignorebind = SOME ``sail2_state_monad$seqS``,
  fail = NONE, choice = NONE, guard = NONE
  });

val _ = temp_enable_monad "sail2_state_monad";
val _ = temp_enable_monadsyntax();


(*open import Pervasives_extra*)
(*open import Sail2_values*)
(*open import Sail2_state_monad*)
(*open import {isabelle} `Sail2_state_monad_lemmas`*)

(*val iterS_aux : forall 'rv 'a 'e. integer -> (integer -> 'a -> monadS 'rv unit 'e) -> list 'a -> monadS 'rv unit 'e*)
 val iterS_aux_defn = Hol_defn "iterS_aux" `
 ((iterS_aux:int ->(int -> 'a -> 'rv sequential_state ->((unit),'e)result#'rv sequential_state) -> 'a list -> 'rv sequential_state ->((unit),'e)result#'rv sequential_state) i f xs=  ((case xs of
    x :: xs => seqS (f i x) (iterS_aux (i +( 1 : int)) f xs)
  | [] => returnS ()
  )))`;

val _ = Lib.with_flag (computeLib.auto_import_definitions, false) Defn.save_defn iterS_aux_defn;

(*val iteriS : forall 'rv 'a 'e. (integer -> 'a -> monadS 'rv unit 'e) -> list 'a -> monadS 'rv unit 'e*)
val _ = Define `
 ((iteriS:(int -> 'a ->('rv,(unit),'e)monadS) -> 'a list -> 'rv sequential_state ->((unit),'e)result#'rv sequential_state) f xs=  (iterS_aux(( 0 : int)) f xs))`;


(*val iterS : forall 'rv 'a 'e. ('a -> monadS 'rv unit 'e) -> list 'a -> monadS 'rv unit 'e*)
val _ = Define `
 ((iterS:('a -> 'rv sequential_state ->((unit),'e)result#'rv sequential_state) -> 'a list -> 'rv sequential_state ->((unit),'e)result#'rv sequential_state) f xs=  (iteriS (\i x .
  (case (i ,x ) of ( _ , x ) => f x )) xs))`;


(*val foreachS : forall 'a 'rv 'vars 'e.
  list 'a -> 'vars -> ('a -> 'vars -> monadS 'rv 'vars 'e) -> monadS 'rv 'vars 'e*)
 val foreachS_defn = Hol_defn "foreachS" `
 ((foreachS:'a list -> 'vars ->('a -> 'vars -> 'rv sequential_state ->('vars,'e)result#'rv sequential_state) -> 'rv sequential_state ->('vars,'e)result#'rv sequential_state) xs vars body=  ((case xs of
    [] => returnS vars
  | x :: xs => bindS
     (body x vars) (\ vars .
     foreachS xs vars body)
)))`;

val _ = Lib.with_flag (computeLib.auto_import_definitions, false) Defn.save_defn foreachS_defn;

(*val genlistS : forall 'a 'rv 'e. (nat -> monadS 'rv 'a 'e) -> nat -> monadS 'rv (list 'a) 'e*)
val _ = Define `
 ((genlistS:(num -> 'rv sequential_state ->('a,'e)result#'rv sequential_state) -> num -> 'rv sequential_state ->(('a list),'e)result#'rv sequential_state) f n=
   (let indices = (GENLIST (\ n .  n) n) in
  foreachS indices [] (\ n xs .  ( bindS(f n) (\ x .  returnS (xs ++ [x]))))))`;


(*val and_boolS : forall 'rv 'e. monadS 'rv bool 'e -> monadS 'rv bool 'e -> monadS 'rv bool 'e*)
val _ = Define `
 ((and_boolS:('rv sequential_state ->((bool),'e)result#'rv sequential_state) ->('rv sequential_state ->((bool),'e)result#'rv sequential_state) -> 'rv sequential_state ->((bool),'e)result#'rv sequential_state) l r=  (bindS l (\ l .  if l then r else returnS F)))`;


(*val or_boolS : forall 'rv 'e. monadS 'rv bool 'e -> monadS 'rv bool 'e -> monadS 'rv bool 'e*)
val _ = Define `
 ((or_boolS:('rv sequential_state ->((bool),'e)result#'rv sequential_state) ->('rv sequential_state ->((bool),'e)result#'rv sequential_state) -> 'rv sequential_state ->((bool),'e)result#'rv sequential_state) l r=  (bindS l (\ l .  if l then returnS T else r)))`;


(*val bool_of_bitU_fail : forall 'rv 'e. bitU -> monadS 'rv bool 'e*)
val _ = Define `
 ((bool_of_bitU_fail:bitU -> 'rv sequential_state ->((bool),'e)result#'rv sequential_state)=
  (\x .  (case x of
               B0 => returnS F
           | B1 => returnS T
           | BU => failS "bool_of_bitU"
         )))`;


(*val bool_of_bitU_nondetS : forall 'rv 'e. bitU -> monadS 'rv bool 'e*)
val _ = Define `
 ((bool_of_bitU_nondetS:bitU -> 'rv sequential_state ->((bool),'e)result#'rv sequential_state)=
  (\x .  (case x of
               B0 => returnS F
           | B1 => returnS T
           | BU => undefined_boolS ()
         )))`;


(*val bools_of_bits_nondetS : forall 'rv 'e. list bitU -> monadS 'rv (list bool) 'e*)
val _ = Define `
 ((bools_of_bits_nondetS:(bitU)list -> 'rv sequential_state ->(((bool)list),'e)result#'rv sequential_state) bits=
   (foreachS bits []
    (\ b bools .  bindS
      (bool_of_bitU_nondetS b) (\ b .
      returnS (bools ++ [b])))))`;


(*val of_bits_nondetS : forall 'rv 'a 'e. Bitvector 'a => list bitU -> monadS 'rv 'a 'e*)
val _ = Define `
 ((of_bits_nondetS:'a Bitvector_class ->(bitU)list ->('rv,'a,'e)monadS)dict_Sail2_values_Bitvector_a bits=  (bindS
  (bools_of_bits_nondetS bits) (\ bs .
  returnS (dict_Sail2_values_Bitvector_a.of_bools_method bs))))`;


(*val of_bits_failS : forall 'rv 'a 'e. Bitvector 'a => list bitU -> monadS 'rv 'a 'e*)
val _ = Define `
 ((of_bits_failS:'a Bitvector_class ->(bitU)list ->('rv,'a,'e)monadS)dict_Sail2_values_Bitvector_a bits=  (maybe_failS "of_bits" (
  dict_Sail2_values_Bitvector_a.of_bits_method bits)))`;


(*val mword_nondetS : forall 'rv 'a 'e. Size 'a => unit -> monadS 'rv (mword 'a) 'e*)
val _ = Define `
 ((mword_nondetS:unit -> 'rv sequential_state ->(('a words$word),'e)result#'rv sequential_state) () =  (bindS
  (bools_of_bits_nondetS (repeat [BU] (int_of_num (dimindex (the_value : 'a itself))))) (\ bs .
  returnS (bitstring$v2w bs))))`;

(*
  * sail2_stateTheory.whileS_def :
      α -> (α -> (β, bool, γ) monad) -> (α -> (β, α, γ) monad) -> (β, α, γ) monad
      whileS vars cond body s = do
        b <- cond vars;
        if b then do
          vars' <- body vars;
          whileS vars' cond body
        od else returnS vars
      od s
    Used in aarch64Theory.semihost_def
      which is used in aarch64Theory.system_exceptions_debug_halt_decode_def
      which is used *once* in aarch64Theory.decode64_def
*)
Definition mwhile_step_def[nocompute]:
  mwhile_step vars cond body 0 s = do b <- cond vars; return (b,vars) od s ∧
  mwhile_step vars cond body (SUC n) s = do
    b <- cond vars;
    if b then do vars' <- body vars; mwhile_step vars' cond body n od
    else returnS (b, vars) od s
End

Theorem mITERATION:
  ∀ cond body . ∃f. ∀vars s. f vars s = do
    b <- cond vars;
    if b then do vars' <- body vars; f vars' od else return vars
  od s
Proof
  rw[] >>
  qexists_tac `λvars s.
    if ∃n. ∀v s'. mwhile_step vars cond body n s ≠ (Value (T,v), s') then
      let n = @n. (∀v s'. mwhile_step vars cond body n s ≠ (Value (T,v), s')) ∧
        ∀m. m < n ⇒ ∃v s'. mwhile_step vars cond body m s = (Value (T,v), s')
      in case mwhile_step vars cond body n s of
        | (Ex e, s') => (Ex e, s')
        | (Value (b,v), s') => (Value v, s')
    else ARB` >>
  reverse (rw[])
  >- (
    fs[] >> first_assum (qspec_then `0` assume_tac) >>
    fs[mwhile_step_def, bindS_def, returnS_def, COND_RATOR] >>
    TOP_CASE_TAC >> TOP_CASE_TAC >> fs[] >> rpt (VAR_EQ_TAC) >>
    first_assum (qspec_then `SUC 0` assume_tac) >>
    fs[mwhile_step_def, bindS_def, returnS_def, COND_RATOR] >> rfs[] >>
    TOP_CASE_TAC >> TOP_CASE_TAC >> fs[] >> rpt (VAR_EQ_TAC) >>
    rw[] >> fs[] >>
    last_x_assum (qspec_then `SUC n` assume_tac) >>
    rfs[mwhile_step_def, bindS_def, returnS_def]
    ) >>
  fs[mwhile_step_def, bindS_def, returnS_def, COND_RATOR] >>
  SELECT_ELIM_TAC >> rw[]
  >- (
    completeInduct_on `n` >> rw[] >>
    Cases_on `
      ∀m. m < n ⇒ ∃v s'. mwhile_step vars cond body m s = (Value (T,v),s')`
    >- (goal_assum drule >> fs[]) >> fs[] >>
    first_x_assum irule >> goal_assum drule >> fs[]
    ) >>
  last_x_assum kall_tac >> rename1 `mwhile_step _ _ _ n _` >>
  Cases_on `n` >> fs[mwhile_step_def, bindS_def, returnS_def, COND_RATOR] >>
  Cases_on `cond vars s` >> fs[] >> rename1 `cond vars s = (v,s')` >>
  Cases_on `v` >> fs[] >> rename1 `if b then _ else _` >>
  Cases_on `b` >> fs[] >> rename1 `SUC n` >>
  Cases_on `body vars s'` >> fs[] >> rename1 `body vars s' = (v, s'')` >>
  Cases_on `v` >> fs[] >> rename1 `Value v` >> reverse (rw[])
  >- (fs[] >> pop_assum (qspec_then `n` assume_tac) >> rfs[]) >>
  SELECT_ELIM_TAC >> rw[]
  >- (
    ntac 4 (last_x_assum kall_tac) >> rename1 `mwhile_step _ _ _ n _` >>
    completeInduct_on `n` >> rw[] >>
    Cases_on `
      ∀m. m < n ⇒ ∃v' s'. mwhile_step v cond body m s'' = (Value (T,v'),s')`
    >- (goal_assum drule >> fs[]) >> fs[] >>
    last_x_assum irule >> goal_assum drule >> fs[]
    ) >>
  qsuff_tac `x = n` >> fs[] >>
  fs[arithmeticTheory.EQ_LESS_EQ, GSYM arithmeticTheory.NOT_LESS] >>
  conj_tac >> CCONTR_TAC >> fs[]
  >- (first_x_assum drule >> strip_tac >> rfs[]) >>
  last_x_assum (qspec_then `SUC x` assume_tac) >>
  rfs[mwhile_step_def, bindS_def, returnS_def]
QED

Theorem whileS_specification:
  ∃f. ∀vars cond body s.
    f vars cond body s = do
      b <- cond vars;
      if b then do vars' <- body vars; f vars' cond body od
      else returnS vars
    od s
Proof
  assume_tac (CONV_RULE SKOLEM_CONV mITERATION) >> fs[] >>
  qexists_tac `λv c b s. f c b v s` >> rw[] >>
  first_assum (once_rewrite_tac o single o GSYM) >>
  first_x_assum (qspecl_then [`cond`,`body`,`vars`,`s`] assume_tac) >> fs[] >>
  CONV_TAC (DEPTH_CONV ETA_CONV) >> fs[]
QED

val whileS_def = new_specification (
  "whileS_def", ["whileS"], whileS_specification);

Theorem whileS_compute[compute] = whileS_def;

Theorem whileS_ind:
  ∀ cond body R.
    WF R ⇒
    (∀vars s t. (Value T,t) = cond vars s ⇒
      ∀vars' u. (Value vars', u) = body vars t ⇒ R (vars',u) (vars,s)) ⇒
    ∀ P.
      (∀vars s.
        (∀t. (Value T, t) = cond vars s ⇒
          ∀vars' u. (Value vars', u) = body vars t ⇒ P (vars', u)) ⇒ P (vars, s))
    ⇒ ∀ vars s. P (vars, s)
Proof
  rw[] >>
  drule relationTheory.WF_INDUCTION_THM >>
  disch_then irule >> rw[] >>
  PairCases_on `x` >> last_x_assum irule >> rw[] >>
  first_x_assum irule >>
  first_x_assum irule >>
  goal_assum drule >> fs[]
QED

(*
  * sail2_stateTheory.untilS_def :
      α -> (α -> (β, bool, γ) monad) -> (α -> (β, α, γ) monad) -> (β, α, γ) monad
      untilS vars cond body s = do
        vars' <- body vars;
        b <- cond vars';
        if b then returnS vars'
        else untilS vars' cond body
      od s
    Used in aarch64Theory.Reset_def and some aarch64Theory.AArch*_TranslationTableWalk*_def
    ⇒ redefine in terms of whileS:
*)
Definition untilS_alt_def[nocompute]:
  untilS vars cond body s = do
    vars' <- body vars;
    whileS vars' (λv. do b <- cond v; return ¬ b od) body;
  od s
End

Theorem bind_step1_eq:
  ∀ m f s f'.
    (∀v s'. (Value v,s') = m s ⇒ f v s' = f' v s')
  ⇒ bindS m f s = bindS m f' s
Proof
  rw[bindS_def] >> TOP_CASE_TAC >> TOP_CASE_TAC >> fs[]
QED

Theorem untilS_def[compute]:
  ∀ vars cond body s.
    untilS vars cond body s = do
      vars' <- body vars;
      b <- cond vars';
      if b then returnS vars'
      else untilS vars' cond body
    od s
Proof
  rw[untilS_alt_def] >>
  irule bind_step1_eq >> rw[] >>
  fs[COND_RATOR, bindS_def, returnS_def, untilS_alt_def, Once whileS_def] >>
  TOP_CASE_TAC >> pop_assum mp_tac >>
  TOP_CASE_TAC >> TOP_CASE_TAC >> fs[] >> rw[] >> fs[]
QED

(*
(*val whileS : forall 'rv 'vars 'e. 'vars -> ('vars -> monadS 'rv bool 'e) ->
                ('vars -> monadS 'rv 'vars 'e) -> monadS 'rv 'vars 'e*)
 val whileS_defn = Hol_defn "whileS" `
 ((whileS:'vars ->('vars -> 'rv sequential_state ->((bool),'e)result#'rv sequential_state) ->('vars -> 'rv sequential_state ->('vars,'e)result#'rv sequential_state) -> 'rv sequential_state ->('vars,'e)result#'rv sequential_state) vars cond body s=
   (( bindS(cond vars) (\ cond_val s' .
  if cond_val then
    ( bindS(body vars) (\ vars s'' .  whileS vars cond body s'')) s'
  else returnS vars s')) s))`;

val _ = Lib.with_flag (computeLib.auto_import_definitions, false) Defn.save_defn whileS_defn;

(*val untilS : forall 'rv 'vars 'e. 'vars -> ('vars -> monadS 'rv bool 'e) ->
                ('vars -> monadS 'rv 'vars 'e) -> monadS 'rv 'vars 'e*)
 val untilS_defn = Hol_defn "untilS" `
 ((untilS:'vars ->('vars -> 'rv sequential_state ->((bool),'e)result#'rv sequential_state) ->('vars -> 'rv sequential_state ->('vars,'e)result#'rv sequential_state) -> 'rv sequential_state ->('vars,'e)result#'rv sequential_state) vars cond body s=
   (( bindS(body vars) (\ vars s' .
  ( bindS(cond vars) (\ cond_val s'' .
  if cond_val then returnS vars s'' else untilS vars cond body s'')) s')) s))`;

val _ = Lib.with_flag (computeLib.auto_import_definitions, false) Defn.save_defn untilS_defn;
*)

(*val choose_boolsS : forall 'rv 'e. nat -> monadS 'rv (list bool) 'e*)
val _ = Define `
 ((choose_boolsS:num -> 'rv sequential_state ->(((bool)list),'e)result#'rv sequential_state) n=  (genlistS (\n .
  (case (n ) of ( _ ) => choose_boolS ()  )) n))`;


(*val internal_pickS : forall 'rv 'a 'e. list 'a -> monadS 'rv 'a 'e*)
val _ = Define `
 ((internal_pickS:'a list -> 'rv sequential_state ->('a,'e)result#'rv sequential_state) xs=  (chooseS xs))`;

val _ = export_theory()

